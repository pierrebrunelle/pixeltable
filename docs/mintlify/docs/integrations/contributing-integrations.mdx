---
title: Contributing to LLMs Support
description: Technical guide for adding new LLM provider integrations to Pixeltable
icon: 'plus'
---

## Required Files

```
pixeltable/
├── .github/workflows/pytest.yml          # CI/CD configuration
├── docs/
│   ├── api/pixeltable/functions/
│   │   └── provider.md                   # API documentation
│   └── notebooks/integrations/
│       └── working-with-provider.ipynb   # Tutorial notebook
├── mkdocs.yml                            # Documentation navigation
├── pixeltable/
│   ├── env.py                            # Package registration
│   └── functions/
│       ├── __init__.py                   # Module exports
│       └── provider.py                   # Main implementation
├── poetry.lock                           # Dependency lock file
├── pyproject.toml                        # Dependency specification
└── tests/functions/
    └── test_provider.py                  # Integration tests
```

## Implementation

### 1. Core Function (`pixeltable/functions/provider.py`)

```python
"""
Pixeltable UDFs that wrap various endpoints from the [Provider] API.
In order to use them, you must first `pip install provider-sdk` and 
configure your credentials, as described in the Working with [Provider] tutorial.
"""

from typing import TYPE_CHECKING, Any, Optional

import pixeltable as pxt
from pixeltable import exprs
from pixeltable.env import Env, register_client
from pixeltable.utils.code import local_public_names

# Import for tool support if using OpenAI-compatible format
from .openai import _openai_response_to_pxt_tool_calls

if TYPE_CHECKING:
    import provider_sdk


@register_client('provider')
def _(api_key: str) -> 'provider_sdk.AsyncClient':
    """Register the provider client with Pixeltable's configuration system."""
    import provider_sdk
    return provider_sdk.AsyncClient(api_key=api_key)


def _provider_client() -> 'provider_sdk.AsyncClient':
    """Get the registered provider client."""
    return Env.get().get_client('provider')


@pxt.udf(resource_pool='request-rate:provider')
async def chat_completions(
    messages: list,
    *,
    model: str,
    model_kwargs: Optional[dict[str, Any]] = None,
    tools: Optional[list[dict[str, Any]]] = None,
    tool_choice: Optional[dict[str, Any]] = None,
) -> dict:
    """
    Chat Completion API.
    
    Equivalent to the [Provider] `chat/completions` API endpoint.
    For additional details, see: <https://docs.provider.com/api-reference>
    
    Request throttling:
    Applies the rate limit set in the config (section `provider`, key `rate_limit`).
    If no rate limit is configured, uses a default of 600 RPM.
    
    __Requirements:__
    
    - `pip install provider-sdk`
    
    Args:
        messages: A list of messages comprising the conversation so far.
        model: ID of the model to use.
        model_kwargs: Additional keyword args for the API.
        tools: List of tools available to the model.
        tool_choice: Controls which (if any) tool is called by the model.
        
    Returns:
        A dictionary containing the response and other metadata.
        
    Examples:
        Add a computed column that applies the model to an existing 
        Pixeltable column `tbl.prompt`:
        
        >>> messages = [{'role': 'user', 'content': tbl.prompt}]
        ... tbl.add_computed_column(
        ...     response=chat_completions(messages, model='provider-model-name')
        ... )
    """
    if model_kwargs is None:
        model_kwargs = {}
        
    Env.get().require_package('provider_sdk')
    
    # Handle tools if supported by the provider
    if tools is not None:
        model_kwargs['tools'] = [{'type': 'function', 'function': tool} for tool in tools]
        
    if tool_choice is not None:
        model_kwargs['tool_choice'] = tool_choice
    
    # Prepare provider-specific parameters if needed
    extra_body: dict[str, Any] = {}
    # Add any provider-specific parameters to extra_body
    
    # Make the API call
    result = await _provider_client().chat.completions.create(
        messages=messages,
        model=model,
        extra_body=extra_body if extra_body else None,
        **model_kwargs,
    )
    return result.model_dump()


# Add tool invocation support if provider uses OpenAI-compatible format
def invoke_tools(tools: pxt.func.Tools, response: exprs.Expr) -> exprs.InlineDict:
    """Converts provider response to Pixeltable tool invocation format."""
    return tools._invoke(_openai_response_to_pxt_tool_calls(response))


__all__ = local_public_names(__name__)


def __dir__() -> list[str]:
    return __all__
```

### 2. Registration

**Module** (`pixeltable/functions/__init__.py`):
```python
from . import provider  # Add in alphabetical order
```

**Package** (`pixeltable/env.py`):
```python
self.__register_package('provider_sdk', library_name='provider-sdk')
```

**API Docs** (`docs/api/pixeltable/functions/provider.md`):
```markdown
## ::: pixeltable.functions.provider
```

**Navigation** (`mkdocs.yml`):
```yaml
- provider: pixeltable/functions/provider.md
```

### 3. Tutorial Notebook (`docs/notebooks/integrations/working-with-provider.ipynb`)

**Cell Structure** (follow `working-with-openai.ipynb` exactly):

| Cell | Type | Content |
|------|------|---------|
| 0 | Markdown | Header with badges, title, prerequisites, notes |
| 1 | Markdown | `First you'll need to install...` |
| 2 | Code | `%pip install -qU pixeltable provider-sdk` |
| 3 | Code | API key setup with `getpass` |
| 4 | Markdown | `Now let's create a Pixeltable directory...` |
| 5 | Code | `pxt.drop_dir()` and `pxt.create_dir()` |
| 6 | Markdown | `## Chat Completions` section |
| 7 | Code | Import, create table, add computed column |
| 8 | Code | Parse response: `t.add_computed_column(response=...)` |
| 9 | Code | Insert demo data and display results |
| 10+ | - | Additional provider-specific features |
| Final | Markdown | `### Learn More` with RAG tutorial link |

**Creation Methods**:
```bash
# Copy existing notebook
cp docs/notebooks/integrations/working-with-openai.ipynb docs/notebooks/integrations/working-with-provider.ipynb

# Or use edit_notebook tool in cursor
```

**Validation**:
```bash
# Check file size (should be >1KB, not 130B)
ls -la docs/notebooks/integrations/working-with-provider.ipynb

# Test execution
jupyter nbconvert --to notebook --execute docs/notebooks/integrations/working-with-provider.ipynb
```

### 4. Dependencies & CI

**Dependencies** (`pyproject.toml`):
```toml
[tool.poetry.dependencies]
provider-sdk = {version = "^1.0.0", optional = true}

[tool.poetry.extras]
provider = ["provider-sdk"]
```

**CI Environment** (`.github/workflows/pytest.yml`):
```yaml
env:
  PROVIDER_API_KEY: ${{ secrets.PROVIDER_API_KEY }}
```

**Lock dependencies**:
```bash
poetry lock
```

### 5. Tests (`tests/functions/test_provider.py`)

```python
import pytest
import pixeltable as pxt
from ..conftest import DO_RERUN
from ..utils import skip_test_if_no_client, skip_test_if_not_installed, validate_update_status

@pytest.mark.remote_api
@pytest.mark.flaky(reruns=3, reruns_delay=8, condition=DO_RERUN)
class TestProvider:
    def test_chat_completions(self, reset_db: None) -> None:
        skip_test_if_not_installed('provider_sdk')
        skip_test_if_no_client('provider')
        from pixeltable.functions.provider import chat_completions
        
        t = pxt.create_table('test_tbl', {'input': pxt.String})
        msgs = [{'role': 'user', 'content': t.input}]
        t.add_computed_column(output=chat_completions(messages=msgs, model='model-name'))
        
        validate_update_status(t.insert(input='What is the capital of France?'), 1)
        results = t.collect()
        assert len(results['output'][0]['choices'][0]['message']['content']) > 0
        assert 'Paris' in results['output'][0]['choices'][0]['message']['content']

    def test_tool_invocations(self, reset_db: None) -> None:
        # Use existing stock_price tool from tool_utils
        from tests.functions.tool_utils import stock_price
        tools = pxt.tools(stock_price)
        # Test with "What is the stock price of NVDA?" -> expects 131.17
```



## Validation & Testing

**Pre-submission checks**:
```bash
FILES="pixeltable/functions/provider.py tests/functions/test_provider.py"

ruff format $FILES                    # Format code
ruff format --check $FILES            # Verify formatting
ruff check --select I $FILES          # Check imports
ruff check $FILES                     # Lint
python -m mypy $FILES --no-error-summary  # Type check
python -m py_compile $FILES           # Syntax check
pytest tests/functions/test_provider.py -m remote_api  # Test
```

**Common fixes**:
- Use `messages: list` not `messages: list[dict[str, Any]]`
- Add type annotations: `extra_body: dict[str, Any] = {}`
- Use existing tools from `tool_utils` for testing

## Checklist

**Core Files**:
- [ ] `pixeltable/functions/provider.py` - main implementation
- [ ] `pixeltable/functions/__init__.py` - add import
- [ ] `pixeltable/env.py` - register package
- [ ] `docs/api/pixeltable/functions/provider.md` - API docs
- [ ] `docs/notebooks/integrations/working-with-provider.ipynb` - tutorial
- [ ] `mkdocs.yml` - navigation entry
- [ ] `pyproject.toml` - dependencies + `poetry lock`
- [ ] `.github/workflows/pytest.yml` - API key

**Validation**:
- [ ] All pre-submission checks pass (format, lint, type, syntax, test)
- [ ] Notebook executable start-to-finish
- [ ] Uses `messages: list` (not `list[dict[str, Any]]`)
- [ ] Tests use existing tools from `tool_utils`

**Need Help?** Check existing integrations, [GitHub Discussions](https://github.com/pixeltable/pixeltable/discussions), or [Discord](https://discord.gg/QPyqFYx2UN).